{
  "version": 3,
  "sources": ["../src/auth/client.ts", "../src/auth/utils.ts", "../src/auth/server.ts", "../src/auth/tokenManager.ts", "../src/auth-server.ts"],
  "sourcesContent": ["import { OAuth2Client } from 'google-auth-library';\nimport * as fs from 'fs/promises';\nimport { getKeysFilePath } from './utils.js';\n\nexport async function initializeOAuth2Client(): Promise<OAuth2Client> {\n  try {\n    const keysContent = await fs.readFile(getKeysFilePath(), \"utf-8\");\n    const keys = JSON.parse(keysContent);\n\n    const { client_id, client_secret, redirect_uris } = keys.installed;\n\n    // Use the first redirect URI as the default for the base client\n    return new OAuth2Client({\n      clientId: client_id,\n      clientSecret: client_secret,\n      redirectUri: redirect_uris[0], \n    });\n  } catch (error) {\n    throw new Error(`Error loading OAuth keys: ${error instanceof Error ? error.message : error}`);\n  }\n}\n\nexport async function loadCredentials(): Promise<{ client_id: string; client_secret: string }> {\n  try {\n    const keysContent = await fs.readFile(getKeysFilePath(), \"utf-8\");\n    const keys = JSON.parse(keysContent);\n    const { client_id, client_secret } = keys.installed;\n    if (!client_id || !client_secret) {\n        throw new Error('Client ID or Client Secret missing in keys file.');\n    }\n    return { client_id, client_secret };\n  } catch (error) {\n    throw new Error(`Error loading credentials: ${error instanceof Error ? error.message : error}`);\n  }\n} ", "import * as path from 'path';\nimport { fileURLToPath } from 'url';\n\n// Helper to get the project root directory reliably\nfunction getProjectRoot(): string {\n  const __dirname = path.dirname(fileURLToPath(import.meta.url)); \n  // In build output (e.g., build/bundle.js), __dirname is .../build\n  // Go up ONE level to get the project root\n  const projectRoot = path.join(__dirname, \"..\"); // Corrected: Go up ONE level\n  return path.resolve(projectRoot); // Ensure absolute path\n}\n\n// Returns the absolute path for the saved token file.\nexport function getSecureTokenPath(): string {\n  const projectRoot = getProjectRoot();\n  const tokenPath = path.join(projectRoot, \".gcp-saved-tokens.json\");\n  return tokenPath; // Already absolute from getProjectRoot\n}\n\n// Returns the absolute path for the GCP OAuth keys file.\nexport function getKeysFilePath(): string {\n  const projectRoot = getProjectRoot();\n  const keysPath = path.join(projectRoot, \"gcp-oauth.keys.json\"); \n  return keysPath; // Already absolute from getProjectRoot\n} ", "import express from 'express';\nimport { OAuth2Client } from 'google-auth-library';\nimport { TokenManager } from './tokenManager.js';\nimport http from 'http';\nimport open from 'open';\nimport { loadCredentials } from './client.js';\n\nexport class AuthServer {\n  private baseOAuth2Client: OAuth2Client; // Used by TokenManager for validation/refresh\n  private flowOAuth2Client: OAuth2Client | null = null; // Used specifically for the auth code flow\n  private app: express.Express;\n  private server: http.Server | null = null;\n  private tokenManager: TokenManager;\n  private portRange: { start: number; end: number };\n  public authCompletedSuccessfully = false; // Flag for standalone script\n\n  constructor(oauth2Client: OAuth2Client) {\n    this.baseOAuth2Client = oauth2Client;\n    this.tokenManager = new TokenManager(oauth2Client);\n    this.app = express();\n    this.portRange = { start: 3000, end: 3004 };\n    this.setupRoutes();\n  }\n\n  private setupRoutes(): void {\n    this.app.get('/', (req, res) => {\n      // Generate the URL using the active flow client if available, else base\n      const clientForUrl = this.flowOAuth2Client || this.baseOAuth2Client;\n      const scopes = ['https://www.googleapis.com/auth/calendar'];\n      const authUrl = clientForUrl.generateAuthUrl({\n        access_type: 'offline',\n        scope: scopes,\n        prompt: 'consent'\n      });\n      res.send(`<h1>Google Calendar Authentication</h1><a href=\"${authUrl}\">Authenticate with Google</a>`);\n    });\n\n    this.app.get('/oauth2callback', async (req, res) => {\n      const code = req.query.code as string;\n      if (!code) {\n        res.status(400).send('Authorization code missing');\n        return;\n      }\n      // IMPORTANT: Use the flowOAuth2Client to exchange the code\n      if (!this.flowOAuth2Client) {\n        res.status(500).send('Authentication flow not properly initiated.');\n        return;\n      }\n      try {\n        const { tokens } = await this.flowOAuth2Client.getToken(code);\n        // Save tokens using the TokenManager (which uses the base client)\n        await this.tokenManager.saveTokens(tokens);\n        this.authCompletedSuccessfully = true;\n\n        // Get the path where tokens were saved\n        const tokenPath = this.tokenManager.getTokenPath();\n\n        // Send a more informative HTML response including the path\n        res.send(`\n          <!DOCTYPE html>\n          <html lang=\"en\">\n          <head>\n              <meta charset=\"UTF-8\">\n              <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n              <title>Authentication Successful</title>\n              <style>\n                  body { font-family: sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; background-color: #f4f4f4; margin: 0; }\n                  .container { text-align: center; padding: 2em; background-color: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n                  h1 { color: #4CAF50; }\n                  p { color: #333; margin-bottom: 0.5em; }\n                  code { background-color: #eee; padding: 0.2em 0.4em; border-radius: 3px; font-size: 0.9em; }\n              </style>\n          </head>\n          <body>\n              <div class=\"container\">\n                  <h1>Authentication Successful!</h1>\n                  <p>Your authentication tokens have been saved successfully to:</p>\n                  <p><code>${tokenPath}</code></p>\n                  <p>You can now close this browser window.</p>\n              </div>\n          </body>\n          </html>\n        `);\n      } catch (error: unknown) {\n        this.authCompletedSuccessfully = false;\n        const message = error instanceof Error ? error.message : 'Unknown error';\n        // Send an HTML error response\n        res.status(500).send(`\n          <!DOCTYPE html>\n          <html lang=\"en\">\n          <head>\n              <meta charset=\"UTF-8\">\n              <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n              <title>Authentication Failed</title>\n              <style>\n                  body { font-family: sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; background-color: #f4f4f4; margin: 0; }\n                  .container { text-align: center; padding: 2em; background-color: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n                  h1 { color: #F44336; }\n                  p { color: #333; }\n              </style>\n          </head>\n          <body>\n              <div class=\"container\">\n                  <h1>Authentication Failed</h1>\n                  <p>An error occurred during authentication:</p>\n                  <p><code>${message}</code></p>\n                  <p>Please try again or check the server logs.</p>\n              </div>\n          </body>\n          </html>\n        `);\n      }\n    });\n  }\n\n  async start(openBrowser = true): Promise<boolean> {\n    if (await this.tokenManager.validateTokens()) {\n      this.authCompletedSuccessfully = true;\n      return true;\n    }\n    \n    // Try to start the server and get the port\n    const port = await this.startServerOnAvailablePort();\n    if (port === null) {\n      this.authCompletedSuccessfully = false;\n      return false;\n    }\n\n    // Successfully started server on `port`. Now create the flow-specific OAuth client.\n    try {\n      const { client_id, client_secret } = await loadCredentials();\n      this.flowOAuth2Client = new OAuth2Client(\n        client_id,\n        client_secret,\n        `http://localhost:${port}/oauth2callback`\n      );\n    } catch (error) {\n        // Could not load credentials, cannot proceed with auth flow\n        this.authCompletedSuccessfully = false;\n        await this.stop(); // Stop the server we just started\n        return false;\n    }\n\n    if (openBrowser) {\n      // Generate Auth URL using the newly created flow client\n      const authorizeUrl = this.flowOAuth2Client.generateAuthUrl({\n        access_type: 'offline',\n        scope: ['https://www.googleapis.com/auth/calendar'],\n        prompt: 'consent'\n      });\n      await open(authorizeUrl);\n    }\n\n    return true; // Auth flow initiated\n  }\n\n  private async startServerOnAvailablePort(): Promise<number | null> {\n    for (let port = this.portRange.start; port <= this.portRange.end; port++) {\n      try {\n        await new Promise<void>((resolve, reject) => {\n          // Create a temporary server instance to test the port\n          const testServer = this.app.listen(port, () => {\n            this.server = testServer; // Assign to class property *only* if successful\n            resolve();\n          });\n          testServer.on('error', (err: NodeJS.ErrnoException) => {\n            if (err.code === 'EADDRINUSE') {\n              // Port is in use, close the test server and reject\n              testServer.close(() => reject(err)); \n            } else {\n              // Other error, reject\n              reject(err);\n            }\n          });\n        });\n        return port; // Port successfully bound\n      } catch (error: unknown) {\n        // Check if it's EADDRINUSE, otherwise rethrow or handle\n        if (!(error instanceof Error && 'code' in error && error.code === 'EADDRINUSE')) {\n            // An unexpected error occurred during server start\n            return null;\n        }\n        // EADDRINUSE occurred, loop continues\n      }\n    }\n    return null; // No port found\n  }\n\n  public getRunningPort(): number | null {\n    if (this.server) {\n      const address = this.server.address();\n      if (typeof address === 'object' && address !== null) {\n        return address.port;\n      }\n    }\n    return null;\n  }\n\n  async stop(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      if (this.server) {\n        this.server.close((err) => {\n          if (err) {\n            reject(err);\n          } else {\n            this.server = null;\n            resolve();\n          }\n        });\n      } else {\n        resolve();\n      }\n    });\n  }\n} ", "import { OAuth2Client, Credentials } from 'google-auth-library';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { getSecureTokenPath } from './utils.js';\nimport { GaxiosError } from 'gaxios';\n\nexport class TokenManager {\n  private oauth2Client: OAuth2Client;\n  private tokenPath: string;\n\n  constructor(oauth2Client: OAuth2Client) {\n    this.oauth2Client = oauth2Client;\n    this.tokenPath = getSecureTokenPath();\n    this.setupTokenRefresh();\n  }\n\n  // Method to expose the token path\n  public getTokenPath(): string {\n    return this.tokenPath;\n  }\n\n  private async ensureTokenDirectoryExists(): Promise<void> {\n    try {\n        const dir = path.dirname(this.tokenPath);\n        await fs.mkdir(dir, { recursive: true });\n    } catch (error: unknown) {\n        // Ignore errors if directory already exists, re-throw others\n        if (error instanceof Error && 'code' in error && error.code !== 'EEXIST') {\n            console.error('Failed to create token directory:', error);\n            throw error;\n        }\n    }\n  }\n\n  private setupTokenRefresh(): void {\n    this.oauth2Client.on(\"tokens\", async (newTokens) => {\n      try {\n        await this.ensureTokenDirectoryExists();\n        const currentTokens = JSON.parse(await fs.readFile(this.tokenPath, \"utf-8\"));\n        const updatedTokens = {\n          ...currentTokens,\n          ...newTokens,\n          refresh_token: newTokens.refresh_token || currentTokens.refresh_token,\n        };\n        await fs.writeFile(this.tokenPath, JSON.stringify(updatedTokens, null, 2), {\n          mode: 0o600,\n        });\n        console.error(\"Tokens updated and saved\");\n      } catch (error: unknown) {\n        // Handle case where currentTokens might not exist yet\n        if (error instanceof Error && 'code' in error && error.code === 'ENOENT') { \n          try {\n             await fs.writeFile(this.tokenPath, JSON.stringify(newTokens, null, 2), { mode: 0o600 });\n             console.error(\"New tokens saved\");\n          } catch (writeError) {\n            console.error(\"Error saving initial tokens:\", writeError);\n          }\n        } else {\n            console.error(\"Error saving updated tokens:\", error);\n        }\n      }\n    });\n  }\n\n  async loadSavedTokens(): Promise<boolean> {\n    try {\n      await this.ensureTokenDirectoryExists();\n      if (\n        !(await fs\n          .access(this.tokenPath)\n          .then(() => true)\n          .catch(() => false))\n      ) {\n        console.error(\"No token file found at:\", this.tokenPath);\n        return false;\n      }\n\n      const tokens = JSON.parse(await fs.readFile(this.tokenPath, \"utf-8\"));\n\n      if (!tokens || typeof tokens !== \"object\") {\n        console.error(\"Invalid token format in file:\", this.tokenPath);\n        return false;\n      }\n\n      this.oauth2Client.setCredentials(tokens);\n      return true;\n    } catch (error: unknown) {\n      console.error(\"Error loading tokens:\", error);\n      // Attempt to delete potentially corrupted token file\n      if (error instanceof Error && 'code' in error && error.code !== 'ENOENT') { \n          try { \n              await fs.unlink(this.tokenPath); \n              console.error(\"Removed potentially corrupted token file\") \n            } catch (unlinkErr) { /* ignore */ } \n      }\n      return false;\n    }\n  }\n\n  async refreshTokensIfNeeded(): Promise<boolean> {\n    const expiryDate = this.oauth2Client.credentials.expiry_date;\n    const isExpired = expiryDate\n      ? Date.now() >= expiryDate - 5 * 60 * 1000 // 5 minute buffer\n      : !this.oauth2Client.credentials.access_token; // No token means we need one\n\n    if (isExpired && this.oauth2Client.credentials.refresh_token) {\n      console.error(\"Auth token expired or nearing expiry, refreshing...\");\n      try {\n        const response = await this.oauth2Client.refreshAccessToken();\n        const newTokens = response.credentials;\n\n        if (!newTokens.access_token) {\n          throw new Error(\"Received invalid tokens during refresh\");\n        }\n        // The 'tokens' event listener should handle saving\n        this.oauth2Client.setCredentials(newTokens);\n        console.error(\"Token refreshed successfully\");\n        return true;\n      } catch (refreshError) {\n        if (refreshError instanceof GaxiosError && refreshError.response?.data?.error === 'invalid_grant') {\n            console.error(\"Error refreshing auth token: Invalid grant. Token likely expired or revoked. Please re-authenticate.\");\n            // Optionally clear the potentially invalid tokens here\n            // await this.clearTokens(); \n            return false; // Indicate failure due to invalid grant\n        } else {\n            // Handle other refresh errors\n            console.error(\"Error refreshing auth token:\", refreshError);\n            return false;\n        }\n      }\n    } else if (!this.oauth2Client.credentials.access_token && !this.oauth2Client.credentials.refresh_token) {\n        console.error(\"No access or refresh token available. Please re-authenticate.\");\n        return false;\n    } else {\n        // Token is valid or no refresh token available\n        return true;\n    }\n  }\n\n  async validateTokens(): Promise<boolean> {\n    if (!this.oauth2Client.credentials || !this.oauth2Client.credentials.access_token) {\n        // Try loading first if no credentials set\n        if (!(await this.loadSavedTokens())) {\n            return false; // No saved tokens to load\n        }\n        // Check again after loading\n        if (!this.oauth2Client.credentials || !this.oauth2Client.credentials.access_token) {\n            return false; // Still no token after loading\n        }\n    }\n    return this.refreshTokensIfNeeded();\n  }\n\n  async saveTokens(tokens: Credentials): Promise<void> {\n    try {\n        await this.ensureTokenDirectoryExists();\n        await fs.writeFile(this.tokenPath, JSON.stringify(tokens, null, 2), { mode: 0o600 });\n        this.oauth2Client.setCredentials(tokens);\n        console.error(\"Tokens saved successfully to:\", this.tokenPath);\n    } catch (error: unknown) {\n        console.error(\"Error saving tokens:\", error);\n        throw error;\n    }\n  }\n\n  async clearTokens(): Promise<void> {\n    try {\n      this.oauth2Client.setCredentials({}); // Clear in memory\n      await fs.unlink(this.tokenPath);\n      console.error(\"Tokens cleared successfully\");\n    } catch (error: unknown) {\n      if (error instanceof Error && 'code' in error && error.code === 'ENOENT') {\n        // File already gone, which is fine\n        console.error(\"Token file already deleted\");\n      } else {\n        console.error(\"Error clearing tokens:\", error);\n        // Don't re-throw, clearing is best-effort\n      }\n    }\n  }\n} ", "import { initializeOAuth2Client } from './auth/client.js';\nimport { AuthServer } from './auth/server.js';\n\n// Main function to run the authentication server\nasync function runAuthServer() {\n  let authServer: AuthServer | null = null; // Keep reference for cleanup\n  try {\n    // Initialize OAuth client\n    const oauth2Client = await initializeOAuth2Client();\n    \n    // Create and start the auth server\n    authServer = new AuthServer(oauth2Client);\n    \n    // Start with browser opening (true by default)\n    const success = await authServer.start(true);\n    \n    if (!success && !authServer.authCompletedSuccessfully) {\n      // Failed to start and tokens weren't already valid\n      process.stderr.write('Authentication failed. Could not start server or validate existing tokens. Check port availability (3000-3004) and try again.\\n');\n      process.exit(1);\n    } else if (authServer.authCompletedSuccessfully) {\n      // Auth was successful (either existing tokens were valid or flow completed just now)\n      process.stderr.write('Authentication successful.\\n');\n      process.exit(0); // Exit cleanly if auth is already done\n    }\n    \n    // If we reach here, the server started and is waiting for the browser callback\n    process.stderr.write('Authentication server started. Please complete the authentication in your browser...\\n');\n    \n    // Poll for completion or handle SIGINT\n    const pollInterval = setInterval(async () => {\n      if (authServer?.authCompletedSuccessfully) {\n        clearInterval(pollInterval);\n        await authServer.stop();\n        process.stderr.write('Authentication successful. Server stopped.\\n');\n        process.exit(0);\n      }\n    }, 1000); // Check every second\n\n    // Handle process termination (SIGINT)\n    process.on('SIGINT', async () => {\n      clearInterval(pollInterval); // Stop polling\n      if (authServer) {\n        await authServer.stop();\n      }\n      process.exit(0);\n    });\n    \n  } catch (error: unknown) {\n    process.stderr.write(`Authentication error: ${error instanceof Error ? error.message : 'Unknown error'}\\n`);\n    if (authServer) await authServer.stop(); // Attempt cleanup\n    process.exit(1);\n  }\n}\n\n// Run the auth server if this file is executed directly\nif (import.meta.url.endsWith('auth-server.js')) {\n  runAuthServer().catch((error: unknown) => {\n    process.stderr.write(`Unhandled error: ${error instanceof Error ? error.message : 'Unknown error'}\\n`);\n    process.exit(1);\n  });\n}"],
  "mappings": "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",
  "names": ["OAuth2Client", "fs", "path", "OAuth2Client", "resolve"]
}
